üß± MATHBOT: MVP ARCHITECTURE (Staff Engineer Plan)

‚∏ª

üéØ GOAL (MVP)

Build a modular Python-based system that:
	1.	Ingests math content from textbooks (PDF, LaTeX).
	2.	Structures content into a searchable knowledge graph.
	3.	Validates formulas via test-driven numerical and symbolic checks.
	4.	Supports incremental expansion, new book ingestion, and concept enrichment.

‚∏ª

üìÇ PROJECT STRUCTURE

mathbot/
‚îú‚îÄ‚îÄ ingestion/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ parser.py              # Extracts text & formulas from PDF/LaTeX
‚îÇ   ‚îú‚îÄ‚îÄ formula_extractor.py   # Identifies math expressions, normalizes symbols
‚îÇ   ‚îî‚îÄ‚îÄ cleaner.py             # Cleans and standardizes raw inputs
‚îú‚îÄ‚îÄ knowledge/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ graph_builder.py       # Builds & updates knowledge graph
‚îÇ   ‚îú‚îÄ‚îÄ node.py                # Represents mathematical entities
‚îÇ   ‚îî‚îÄ‚îÄ topics.json            # Initial taxonomy of math topics
‚îú‚îÄ‚îÄ validation/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_runner.py         # Runs numerical tests against symbolic formulas
‚îÇ   ‚îî‚îÄ‚îÄ formula_tester.py      # Generates test cases, handles edge values
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ raw/                   # Raw files: PDFs, LaTeX sources
‚îÇ   ‚îú‚îÄ‚îÄ processed/             # Parsed text and formulas
‚îÇ   ‚îî‚îÄ‚îÄ graph/                 # Serialized knowledge graph (e.g., GraphML/JSON)
‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îî‚îÄ‚îÄ exploration.ipynb      # Early exploration, concept visualizations
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_parser.py
‚îÇ   ‚îú‚îÄ‚îÄ test_graph_builder.py
‚îÇ   ‚îî‚îÄ‚îÄ test_formula_validation.py
‚îú‚îÄ‚îÄ main.py                    # Entry point for ingestion and validation
‚îú‚îÄ‚îÄ config.py                  # Constants and environment settings
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md


üß© PHASE 1: INGESTION PIPELINE

1.1 PDF & LaTeX Parsing
	‚Ä¢	‚úÖ Use pdfminer.six or PyMuPDF for PDFs, and pylatexenc or custom tokenizer for LaTeX.
	‚Ä¢	‚úÖ Extract text blocks and math expressions separately.
	‚Ä¢	‚úÖ Normalize formulas into SymPy-compatible form.

Task Example (parser.py):
def extract_text_blocks(pdf_path: str) -> List[str]:
    """Extracts all textual content from a PDF, page by page."""
    ...

def extract_latex_blocks(text: str) -> List[str]:
    """Detects and isolates LaTeX-style formulas from text."""
    ...

1.2 Formula Extraction & Cleanup
	‚Ä¢	‚úÖ Create robust regex patterns and token maps for Greek letters, indices, function aliases.
	‚Ä¢	‚úÖ Resolve notation inconsistencies across sources.

‚∏ª

üß© PHASE 2: KNOWLEDGE GRAPH STRUCTURING

2.1 Define Graph Schema
	‚Ä¢	Nodes: Topic, Concept, Formula, Example
	‚Ä¢	Edges: ‚Äúdepends_on‚Äù, ‚Äúexplains‚Äù, ‚Äúderived_from‚Äù

2.2 Implement graph_builder.py
	‚Ä¢	‚úÖ Use networkx or Neo4j (optional for future expansion)
	‚Ä¢	‚úÖ Enable import/export in GraphML and JSON
class MathNode:
    def __init__(self, id, type, content):
        ...

def add_formula_node(graph, formula: str, topic: str):
    ...

2.3 Topic Taxonomy (topics.json)
	‚Ä¢	Seed with a curated JSON tree:
    {
  "Calculus": ["Limits", "Derivatives", "Integrals"],
  "Algebra": ["Polynomials", "Equations", "Matrices"],
  "Geometry": ["Euclidean", "Analytic", "Transformations"]
}

üß© PHASE 3: FORMULA VALIDATION ENGINE

3.1 Symbolic + Numerical Testing
	‚Ä¢	‚úÖ Use SymPy for:
	‚Ä¢	Simplifications
	‚Ä¢	Substitution-based validation
	‚Ä¢	Symbolic equality checking
	‚Ä¢	‚úÖ Use Python tests with randomized values to verify formulas numerically.

def test_quadratic_formula():
    a, b, c = 2, -3, -2
    roots = solve(a*x**2 + b*x + c, x)
    assert roots == [2, -0.5]

3.2 Edge-Case Handling
	‚Ä¢	‚úÖ Division by zero
	‚Ä¢	‚úÖ Singular matrices
	‚Ä¢	‚úÖ Symbol boundaries (e.g., 0, ¬±‚àû, limits)

‚∏ª

üß© PHASE 4: CONTINUOUS LEARNING LOOP (Skeleton Only for MVP)
	‚Ä¢	Plan and stub methods for:
	‚Ä¢	Embedding formulas for similarity detection
	‚Ä¢	Clustering similar concepts
	‚Ä¢	Detecting underexplored graph regions

‚∏ª

üìä METADATA & LOGGING
	‚Ä¢	Add logging for:
	‚Ä¢	Source tracking (book, page, author, etc.)
	‚Ä¢	Ingestion status
	‚Ä¢	Formula confidence

‚∏ª

üß™ TESTING STRATEGY
	‚Ä¢	Unit tests per module
	‚Ä¢	E2E test simulating book ingestion ‚Üí knowledge graph ‚Üí validation
	‚Ä¢	Use pytest, with tox or nox for test matrix

‚∏ª

üß† FUTURE (Post-MVP, for discussion)
	‚Ä¢	Use embeddings (e.g., MathBERT) to cluster and suggest patterns.
	‚Ä¢	Integrate GPT-f, Lean, or Isabelle for proof exploration.
	‚Ä¢	UI dashboard to visualize and query math knowledge.
	‚Ä¢	Graph ML on the knowledge graph for structural insights.